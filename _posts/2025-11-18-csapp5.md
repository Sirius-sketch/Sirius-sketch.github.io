---
layout: post
title:  "第五章：优化程序性能"
date:   2025-11-19 18:00:00 +0800
categories: [computer]
tags: [github, jekyll]
---

## 5.1 优化编译器的能力和局限性
主要考虑-o1级别的优化  
优化必须是安全的（和未优化的版本在所有情况下行为一样），例如

```C
void twiddle1(long *xp,long *yp)
{
    *xp+=*yp;
    *xp+=*yp;
}
void twiddle2(long *xp,long *yp)
{
    *xp+=2* *yp;
}
```


twiddle2三次引用内存而twiddle1六次引用内存，但是在xp=yp的情况下，twiddle1的xp乘4，twiddle2的xp乘3，因此2不是1的优化版本。这种两个指针指向内存中同一个位置的情况称为内存别名使用，编译器必须假设不同指针可能指向内存中同一位置，限制了可能的优化策略。

第二个妨碍优化因素：函数调用，例如：

```C
long f();
long func1(){
    return f()+f()+f()+f();
}
long fun2(){
    return 4*f()
}
```


当f修改全局程序状态的一部分，改变调用它的次数会改变程序的行为。（内联函数替换优化函数调用，但是只适用于单个文件中定义的函数的内联。无法应用于一组库函数在一个文件中被定义，被其他文件函数调用的情况）。

## 5.2表示程序性能

度量标准：每元素的周期数CPE  
示例：前置和函数

```C
void psum1(float a[],float p[],long n)
{
    long i;
    p[0]=a[0];
    for (i=1;i<n;i++)
        p[i]=p[i-1]+a[i];
}
void psum2(float a[],float p[],long n)
{
    long i;
    p[0]=a[0];
    for (i=1;i<n-1;i+=2){
        float mid_val=p[i-1]+a[i];
        p[i]=mid_val;
        p[i+1]=mid_val+a[i+1];
    }
    if (i<n)
        p[i]=p[i-1]+a[i];
}
```


第二个函使用循环展开技术，每次迭代计算两个元素（好处？）  
这样一个过程所需时间可以用一个常数加上与被处理元素个数成正比的因子来描述，系数称为CPE的有效值

##5.3程序示例
向量由两个内存块表示：头部和数据数组
头部结构如下：

```C
typedef struct{
    long len;
    data_t *data;
}vec_rec,*vec_ptr;
```
